get_network_interface() {
        if [ -n "$MONITORED_NETWORK" ]; then
        # Manual override
                _RET="$MONITORED_NETWORK"
        elif [ -d /proc ]; then
        # Linux systems, read route and interface from procfs
        local Iface Destination Gateway Flags RefCnt Use Metric Mask MTU Window IRTT
        while read Iface Destination Gateway Flags RefCnt Use Metric Mask MTU Window IRTT; do
            [ "$Mask" = "00000000" ] && break
        done < /proc/net/route
        _RET="$Iface"
    else
        # Mac OSX, shell out to the route command
        _RET=$(/sbin/route get default|grep interface:|awk '{print $2}')
    fi  
}

__network_detail() {
    get_network_interface; local interface="$_RET"
    LC_ALL=C /sbin/ifconfig "$interface" | $BYOBU_SED 's/\s*$//'
}

__network() {
    get_network_interface; local interface="$_RET"
    local x1=0 x2=0 tx1=0 i= t= unit= symbol= cache= rate=
    status_freq network
    t="$_RET"
    # By default, we won't bug the user with the display of network traffic
    # below NETWORK_THRESHOLD in kbps; override in $BYOBU_CONFIG_DIR/status
    [ -n "$NETWORK_THRESHOLD" ] || NETWORK_THRESHOLD=20
    for i in up down; do
        unit="kb"
        case $i in
            up) symbol="$ICON_UP" ;;
            down) symbol="$ICON_DN" ;;
        esac
        cache="$BYOBU_RUN_DIR/cache.$BYOBU_BACKEND/network.$i"
        [ -r "$cache" ] && read x1 < "$cache" || tx1=0
        local iface rbytes rpackets rerrs rdrop rfifo rframe rcompressed rmulticast tbytes tpackets terrs tdrop tfifo tcolls tcarrier tcompressed
        while read iface rbytes rpackets rerrs rdrop rfifo rframe rcompressed rmulticast tbytes tpackets terrs tdrop tfifo tcolls tcarrier tcompressed; do
            case "$iface" in
                ${interface}:)
                    [ "$i" = "up" ] && x2=${tbytes} || x2=${rbytes}
                    break;
                ;;  
                ${interface}:*)
                    # Interface and tbytes got munged together
                    [ "$i" = "up" ] && x2=${rmulticast##*:} || x2=${iface##*:}
                    break;
                ;;
                ${interface}:*)
                    # Interface and tbytes got munged together
                    [ "$i" = "up" ] && x2=${rmulticast##*:} || x2=${iface##*:}
                    break;
                ;;
            esac
        done < /proc/net/dev
        printf "%s" "$x2" > "$cache"
        rate=$((8*($x2 - $x1) / $t / 1024))  # in kbps
        [ "$rate" -lt 0 ] && rate=0
        if [ $rate -gt $NETWORK_THRESHOLD ]; then
            case "$NETWORK_UNITS" in
                bytes)
                    rate=$(($rate/8))
                    if [ "$rate" -gt 1048576 ]; then
                        fpdiv "$rate" 1048576 1
                        rate=${_RET}
                        unit="GB/s"
                    elif [ "$rate" -gt 1024 ]; then
                        fpdiv "$rate" 1024 1
                        rate=${_RET}
                        unit="MB/s"
                    else
                        unit="kB/s"
                    fi
                ;;
                *) 
                    # Default to bps
                    # Why 1000 and not 1024?  http://en.wikipedia.org/wiki/Data_rate_units
                    if [ "$rate" -gt 1000000 ]; then
                        fpdiv "$rate" 1000000 1
                        rate=${_RET}
                        unit="Gb"
                    elif [ "$rate" -gt 1000 ]; then
                        fpdiv "$rate" 1000 1
                        rate=${_RET}
                        unit="Mb"
                    fi
                ;;
            esac
            [ -n "$rate" ] || continue
            color b m w; printf "%s%s" "$symbol" "$rate"; color -; color m w; printf "%s" "$unit"; color --
        fi
    done
}


